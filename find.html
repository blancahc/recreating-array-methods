<script src="./simpletest.js"></script>
<script>
//Process:
//1. Read the MDN documentation to learn what the native method does
//2. If necessary, play with it on the DOM. 
//3. If necessary, write a prototype
//4. Write examples of what it should do
//5. Write the english for each test. Think of edge cases. Make them all fail. 
//6. Make each test pass one at a time by writing out your function. 

function find (originalArray, callback, optionalThis){
  var findCallback = callback;

  if(optionalThis){
    findCallback = callback.bind(optionalThis);
  }
  for( var i = 0; i < originalArray.length; i++){
    if(findCallback(originalArray[i], i, originalArray))
    return originalArray[i];
  }
  return 'undefined';
};
tests({
'It should run the callback function array.length times.': function() {
  var numberOfTimeCallbackHasRun = 0;
  find([1, 2, 3], function(){
    numberOfTimeCallbackHasRun++;
  });
  eq(numberOfTimeCallbackHasRun, 3);
},
'It should pass in the ith element as the first argument to the callback.': function() {
  find([1], function(number){
    eq(number, 1);
  });
},
'It should pass in the ith position as the second argument to the callback.': function() {
  find([1], function(number, index){
    eq(index, 0);
  });
},
'It should pass in the original array position as the third argument to the callback.': function() {
  var testArray = [1, 2, 3];
  find(testArray, function(number, index, originalArray){
    eq(originalArray, testArray);
  });
},
'It should pass in an optional this object.': function() {
  find([1], function() {
    eq(this.description, 'I should be accessible inside of the callback')
  }, {description: 'I should be accessible inside of the callback'});
},
'It should only return the first element where callback returns true.': function() {
  var result = find([1, 2, 3], function(number) {
    return number > 1;
  });
  eq(result, 2);
},
'It should return undefined if there are no elements where callback returns true.': function() {
  var result = find([1, 2, 3], function(number) {
    return number > 3;
  });
  eq(result, 'undefined');
},
'It should not mutate the orignal array which is passed.': function() {
  var originalArray = [1, 3];
  find(originalArray, function(number, index, orignalArray) {
    return number > 1;
  });
  eq(originalArray.length, 2);
  eq(originalArray[0], 1);
  eq(originalArray[1], 3);
},
'It should visit all indexes, including those with unassigned values': function() {
  var numberOfTimeCallbackHasRun = 0;
  find([1, 2, ,4], function(){
    numberOfTimeCallbackHasRun++;
  });
  eq(numberOfTimeCallbackHasRun, 4);
},
'If an existing, unvisited element of the array is changed by callback, its value passed to the callback will be the given value at the time find visits that element.': function() {
var testArray = [2,4,8];
var result = find(testArray, function(number, index) {
    if (index === 0) {
      testArray[2] = 11;
    }
    return number > 10;
  });
  eq(result, 11);
},
'It should visit deleted elements and it value will be the value of the index when find visits it.': function() {
var testArray = [0,1,,3,4,5,6];
  find(testArray, function(value, index) {
    if (index === 0) {
      delete testArray[5];
    }
   eq(testArray[5], undefined); 
  });
}
});

</script>
